{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"nginx测试","text":"","link":"/2019/11/08/nginx-01/"},{"title":"redis常用指令","text":"Redis指令通过help命令可以让我们查看Reddis的指令帮助信息： 在help后面跟上空格，然后tab键，会看到Redis对命令分组的组名: 主要包含： @generic: 通用指令 @string: 字符串类型指令 @list: 队列结构指令 @set: set结构指令 @sorted_set: 可排序的set结构 @hash: hash结构指令 其中除了@generic以为的，对应了Redis中常用的5中数据类型: String: 等同于java中的 Map&lt;String,String&gt; list: 等同于java中的 Map&lt;String,List&lt;String&gt;&gt; set: 等同于java中的 Map&lt;String,Set&lt;String&gt;&gt; sort_set: 可排序的set hash: 等同于java中的 Map&lt;String,Map&lt;String,String&gt;&gt; 可见，Redis中存储数据机构都是类似java的map类型。Redis不同数据类型，只是map值的类型不同 通用指令keys获取符合规则的键名列表。 语法：keys pattern 示例：keys * （查询所有的键） 这里的pattern其实是正则表达式，所以语法基本是类似的 生产环境一定要禁用keys(redis是单线程，如果keys* 数据太多，大家都等着吧) 禁用命令 1rename-command KEYS &quot;&quot; 重命名命令 1rename-command KEYS &quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot; exists判断一个键是否存在，如果存在返回整数1 ，否则 返回0 delDEL: 删除key，可以删除一个或多个key，返回删除的key的数量 语法：DEL key[key … ] 示例： expire 语法： 1EXPIRE key seconds 作用：设置key的过期时间，超过时间后，将会自动删除该key. 返回值： 如果成功设置过期时间，返回1。 如果key不存在或者不能设置过期时间，返回0。 selectredis默认有16个库，select 0切换到1号数据库，搭建集群的时候会禁用其他的库，在redis.conf中databases修改 TTLTTL: 查看一个key的过期时间 语法: TTL key 返回值： 返回剩余的过期时间 -1：永不过期（不设置expire默认） -2：已过期 示例 ： persist 语法： 1persist key 作用 移除给定key的生存时间，将这个key从带生存时间key转换成一个不带生存时间，永不过期的key 返回值： 当生存时间移除成功时，返回1. 如果key不存在或key没有设置生存时间，返回0 示例： 字符串指令字符串机构，其实是Redis中最基础的K-V结构。其建和值都是字符串（其实就是存进去字节）。类似java的Map&lt;String,String&gt; 字符串类型是Redis中最基本的数据类型，它能存储任何形式的字符串，包括二进制数据。可以存储JSON化的对象、字节数组等。一个字符串类型键允许存储的数据最大容量是512MB. 常用命令： 语法 说明 SET key value 设置指定key的值 GET key 获取指定key的值 GETRANGE key start end 返回key中字符串值的子字符 INCR key 将key中储存的数字值增一 IINCRBY key increment 将key所储存的值加上给定的增量值（increment） DECR key 将key中储存的值减一 DECRBY key decrement key所储存的值减去给定的减量值（decrement） APPEND key value 如果key已经存在并且是一个字符串，APPEND命令将value追加到key原来的值末尾 STRLEN key 返回key所储存的字符串值长度 MGET key1 key2 … 获取所有（一个或多个）给定的key的值 MSET key value key value 同时设置一个或多个key-value对 incr decr incrby decrby incr key key自增1，如果key不存在，自增后get(key)=1，也就是从0开始 decr key key自减1，如果key不存在，自减后get(key)=-1，也就是从0开始 incrby key k key自增k，如果key 不存在，自增后get(key)=k decrby key k key自减k，如果key不存在，自减后get(key)=-k set setnx setxx不管key是否存在，都设置 set key value key不存在，才设置 setnx key value key存在，才设置 set key value xx 示例： mget msetn次get=n次网络时间+n次命令时间 1次mget=1次网络时间+n次命令时间 mget key1 key2 key 3 批量获取key，原子操作 mset key 批量设置key-value getset、append、strlenset key newvalue 并返回旧的value getset key newvalue 将value追加到旧的value append key value 返回字符串的长度（注意中文） strlen key incrbyfloat getrange setrange增加key对应的值3.5（浮点数） incrbyfloat key 3.5 获取字符串指定下标所有的值 getrange key start end 设置指定下标所有对应的值 setrange key index value 字符串总结 命令 含义 复杂度 set key value 设置key-value o(1) get key 获取key-value o(1) del key 删除key-value o(1) setnx setxx 根据key是否存在设置key-value o(1) incr decr 计数 o(1) mget mset 批量操作key-value o(1) hash结构命令Redis的Hash结构类似于Java中的Map&lt;String,Map&lt;String,String&gt;&gt;，键是字符串，值是另一个映射。结构如图: 这里我们称键为key，字段名为hKey，字段值为hValue 常用指令： HSET、HSETNX和HGET（添加、获取） HSET 介绍： HSET key field value 将哈希表key中的字段field的值设为value Redis Hset命令用于为哈希表中的字段赋值 如果哈希表不存在，一个新的哈希表被创建并进行HSET操作 如果字段已经存在于哈希表中，旧值将被覆盖 返回值： 如果字段是哈希表中的一个新建字段，并且设置成功，返回1 如果字段已经存在于哈希表中且旧值已被新值覆盖，返回0 示例： HGET 介绍：HGET key field 获取存储在哈希表中指定字段的值 返回值：返回给定字段的值，如果给定的字段或key不存在时，返回nil 示例： HDEL（删除）HDEL命令用于删除哈希表key中的一个或多个指定字段，不存在的字段将被忽略 介绍：HDEL key field2 [field2 …] 删除一个或多个哈希表字段 返回值： 被成功删除字段的数量，不包括被忽略的的字段 示例 HGETALL（获取所有） 介绍：HGETALL key 获取在哈希表中指定key的所有字段和值（它的key和value都返回） 返回值： 指定key的所有字段的名及值。返回值里，紧跟每个字段名（field name）之后是字段的值（value），所以返回值的长度是哈希表大小的两倍 示例： HEXISTS、HLEN判断hash key是否有field hexists key field 获取hash key field的数量 hlen key 示例： HMGET、HMSET批量获取hash key的一批field对应的值 hmget key field1 field2… fieldN 批量设置hash key的一批field value hmset key field value1 field2 value2 …. HKEYS 介绍：HKEYS key 获取所有哈希表中的字段 示例 HVALS 介绍：KVALS key 获取哈希表中所有的值 注意：这个命令不是HVALUES，而是HVALS，是value的缩写：val 示例：","link":"/2019/11/09/redis%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"title":"redis持久化","text":"Redis持久化数据持久化方式有： 快照： MySQL Dump Redis RDB 写日志： MySQL Binglog Hbase HLog Redis AOF RDB持久化方式什么是RDB RDB是Redis内存到硬盘的快照，用于持久化 save通常会阻塞Redis bgsave不会阻塞Redis，但是会for新进程 save自动配置满足任一就会被执行 有些触发机制不容忽视 触发机制-只要三种方式save(同步)使用save命令，就会开始以同步命令的方式同步文件 文件策略 生成一个新的文件，替换老的RDB文件 bgsave(异步)使用linux的fork()函数，生成一个redis进程的子进程，生成RDB文件 注意：如果fork()函数执行的慢，依然会阻塞redis，一般fork函数足够快，所以redis会正常的响应客户端 文件策略 和save相同 save和bgsave比较 命令 save bgsave IO类型 同步 异步 是否阻塞 是 是（阻塞发生在fork） 复杂度 O(n) O(n) 优点 不会消耗额外内存 不阻塞客户端命令 缺点 阻塞客户端命令 需要fork,消耗内存 自动Redis提供了RDB的save配置，其实就是内部执行了bgsave 默认配置 60秒内change了10000条数据以上，三个条件满足一个就会触发bgsave stop-writes-on-bgsave-error:bgsave发生异常，停止写入 rdbcompression:是否压缩 rdbchecksum:是否采用校验和的方式 12345678save 900 1save 300 10save 60 10000dbfilename dump.rdbdir ./stop-writes-on-bgsave-error yesrdbcompression yesrdbchecksum yes 最佳配置 12345dbfilename dump-${port}.rdbdir /bigdiskpathstop-writes-on-bgsave-error yesrdbcompression yesrdbchecksum yes 触发机制-不容忽略方式会触发生成RDB文件的方式 全量复制：主从重复的时候 debug reload：不会将内存清空的重启 shutdown：执行shutdown 示例： 12345678910111213141516171819202122232425#端口号port 6379#是否以守护进程的方式执行daemonize yes#生成pid的文件名pidfile /var/run/redis_6379.pid#日志logfile \"6379.log\"#日志级别loglevel notice#RDB配置 注释掉默认配置#save 900 1#save 300 10#save 60 10000#使用的是默认配置，stop-writes-on-bgsave-error yesrdbcompression yesrdbchecksum yes#修改rdb文件dbfilename dump_6379.rdb#修改rdb保存目录dir ./ AOF持久化方式RDB现存问题 耗时、耗性能 redis将内存的数据dump到硬盘当中，生成rdb文件 O(n)数据：耗时 fork()：消耗内存，copy-on-write策略 Disk I/O：IO性能 不可控、丢失数据 时间戳 save T1 执行多个写命令 T2 满足RDB自动的创建的条件 T3 再次执行多个写命令 T4 宕机（在这里就会发生数据丢失） 什么是AOFAOF后台执行的方式和RDB有类似的地方，fork一个子进程，主进程仍进行服务，子进程执行AOF持久化，数据被dump到磁盘上。与RDB不同的是，后台子进程持久化过程中，主进程会记录期间的所有数据变更（主进程还在服务），并存储在server.aof_rewrite_buf_blocks中；后台子进程结束后，Redis更新缓存到AOF文件中，是RDB持久化所不具备的。 更新缓存可以存储在 server.aofbuf 中，你可以把它理解为一个小型临时中转站，所有累积的更新缓存都会先放入这里，它会在特定时机写入文件或者插入到server.aof-rewrite_buf_blocks 下链表（下面会详述）；server.aofbuf 中的数据在 propagrate() 添加，在涉及数据更新的地方都会调用propagrate() 以累积变更。更新缓存也可以存储在 server.aof-rewrite_buf_blocks，这是一个元素类型为 struct aofrwblock 的链表，你可以把它理解为一个仓库，当后台有AOF 子进程的时候，会将累积的更新缓存（在 server.aof_buf 中）插入到链表中，而当 AOF 子进程结束，它会被整个写入到文件。两者是有关联的。 这里的意图即是不用每次出现数据变更的时候都触发一个写操作，可以将写操作先缓存到内存中，待到合适的时机写入到磁盘，如此避免频繁的写操作。当然，完全可以实现让数据变更及时更新到磁盘中。两种做法的好坏就是一种博弈了。 这里有两篇文章，一篇讲AOF的write和save https://blog.csdn.net/luolaifa000/article/details/84178289 一篇通过源码角度看redis AOF https://www.cnblogs.com/williamjie/p/9546663.html AOF三种策略always 每条命令都写入到硬盘当中 everysec 每秒把数据刷新到硬盘（是配置的默认值） no 由系统决定什么时候刷新 always、everysec、no 命令 always everysec no 优点 不丢失数据 每秒一次fsync丢1秒数据 不用管 缺点 IO开销较大，一般的sata盘只有几百TPS 丢1秒数据 不可控 AOF重写AOP重写的好处 减少磁盘用量 加快恢复速度 AOP重写实现的两种方式bgrewriteaof（这里就是往硬盘里重写数据，上面的图只是为了演示） AOF重写配置实际上也是执行了bgrewriteaof 配置 1234#AOF文件重写需要的尺寸auto-aof-rewrite-min-size#AOF文件增长率auto-aof-rewrite-percentage 统计 1234#AOF当前尺寸（单位：字节）aof_current_size#AOF上次启动和重写的尺寸（单位：字节）aof_base_size 自动触发时机 #当前尺寸大于最小尺寸aof_current_size &gt; auto-aof-rewrite-min-size#增长率 当前尺寸-上一次重写(或者重启)的尺寸/上一次重写(或者重启)的尺寸 &gt;aof_current_size - aof_base_size/aof_base_size &gt; auto-aof-rewrite-percentage AOF重写流程 AOF配置1234567891011121314151617181920#将AOF功能打开appendonly yes#AOF的文件名appendfilename \"appendonly-${port}.aof\"#AOF同步的三种策略appendfsync everysec#保存rdb aof 和日志的目录dir /bigdiskpath#AOF重写的时候，是否要做AOF的apend操作(这里配置的是不进行次操作)，就是在AOF重写的时候（比较消耗性能），这段时间是否继续写AOF，如果AOF重写失败，no-appendfsync-on-rewrite yes#增长率auto-aof-rewrite-percentage 100#尺寸auto-aof-rewrite-min-size 64mb no-appendfsync-on-rewrite解释： bgrewriteaof机制，在一个子进程中进行aof的重写，从而不阻塞主进程对其余命令的处理，同时解决了aof文件过大问题。 现在问题出现了，同时在执行bgrewriteaof操作和主进程写aof文件的操作，两者都会操作磁盘，而bgrewriteaof往往会涉及大量磁盘操作，这样就会造成主进程在写aof文件的时候出现阻塞的情形，现在no-appendfsync-on-rewrite参数出场了。如果该参数设置为no，是最安全的方式，不会丢失数据，但是要忍受阻塞的问题。如果设置为yes呢？这就相当于将appendfsync设置为no，这说明并没有执行磁盘操作，只是写入了缓冲区，因此这样并不会造成阻塞（因为没有竞争磁盘），但是如果这个时候redis挂掉，就会丢失数据。丢失多少数据呢？在linux的操作系统的默认设置下，最多会丢失30s的数据。 aof 和 rdb 是两个机制, 没有什么关系如果 no-appendfsync-on-rewrite=yes, 这个时候主线程的 set 操作会被阻塞掉, 由于没有新的值写入 redis, 所有就没有这个时候数据丢失的可能. 一旦 tmp.aof 重写成功, 就不会有数据丢失.如果no-appendfsync-on-rewrite=no, 这个时候主线程的 set 操作不会阻塞, 就会有新值写入 redis,但是这部分记录不会同步到硬盘上, 就会有数据丢失的问题可能. 一旦 tmp.aof 重写成功就发生故障, 就会产生数据丢失. AOF试验123456789#查看AOF功能是否打开，config get appendonlyconfig set appendonly#将 appendonly 的修改写入到 redis.conf 中config rewrite#这时候应该就生成了aof文件#开始aof重写数据bgrewriteaof 一篇AOF持久化的文章 https://blog.csdn.net/yangyutong0506/article/details/46880773 RDB和AOF的抉择RDB和AOF比较 命令 RDB AOF 启动优先级 低 高 体积 小 大 恢复速度 快 慢 数据安全性 丢数据 根据策略决定 轻重 重 轻 RDB最佳策略 关 集中管理 主从，从开 AOF最佳策略 “开”：缓存和存储 AOF重写集中管理 everysec(每秒) 最佳策略 小分片(maxmemory) 缓存或者存储 监控（硬盘、内存、负载、网络） 足够的内存 开发运维常见问题fork操作 同步操作 for操作只是做内存页的拷贝，而不是内存的拷贝，但是如果fork操作阻塞了，会阻塞redis主线程 与内存量息息相关：内存越大，耗时越长（与机器类型有关） info:latest_fork_userc(查看上一次执行fork时使用的微秒数) 改善fork 优先使用物理机或者高效支持fork操作的虚拟化技术 控制Redis实例最大可用内存：maxmemory 合理配置Linux内存分配策略：vm.overcommit_memory=1(默认是0) 降低fork频率：例如放款AOF重写的自动触发机制，不必要的全量复制 子进程的开销和优化 CPU 开销：RDB和AOF文件生成（主要体现在文件的重写bgsave、bgrewriteaof将内存的数据写到硬盘），属于CPU密集型 优化：不做CPU绑定，不和CPU密集型部署 内存 开销：fork内存开销，copy-on-write（linux父子进程会共享相同的物理内存文件，父进程有写请求的时候，数据会被复制，从而使各个进程拥有各自的拷贝，这时候才会消耗内存）。 优化：echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled (不允许单机多实例的时候产生大量的重写，然后在主进程写入量比较少的时候去做一个bgsave或者aof重写，再就是这个配置，linux在2.6.38版本里面增加了THP的特性，支持大的内存页的分配，由原来的4k变成2m) 硬盘 开销：AOF和RDB文件写入，可以结合iostat,iotop分析 不要和高硬盘负载服务部署在一起：存储服务、消息队列等 no-appendfsync-on-rewrite = yes (禁止AOF重写时追加的操作) 根据写入量决定磁盘类型 ：例如ssd 单机多实例持久化文件目录可以考虑分盘 AOF追加阻塞原理看一下下面追加的AOF保存 从 和info persistence命令（每发生一次，就会加1） 都可以看到 还可以通过top命令 单机多实例部署AOF保存AOF文件写入和保存每当服务器常规任务函数被执行、 或者事件处理器被执行时， aof.c/flushAppendOnlyFile 函数都会被调用， 这个函数执行以下两个工作： WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件。 SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。 两个步骤都需要根据一定的条件来执行， 而这些条件由 AOF 所使用的保存模式来决定， 以下小节就来介绍 AOF 所使用的三种保存模式， 以及在这些模式下， 步骤 WRITE 和 SAVE 的调用条件。 AOF保存模式Redis目前支持三种AOF保存模式，它们分别是： AOF_FSYNC_NO: 不保存 AOF_FSYNC_EVERYSEC: 每一秒保存一次 AOF_FSYNC_ALWAYS: 每执行一个命令保存一次 不保存在这种模式下， 每次调用 flushAppendOnlyFile 函数， WRITE 都会被执行， 但 SAVE 会被略过。 在这种模式下， SAVE 只会在以下任意一种情况中被执行： Redis 被关闭 AOF 功能被关闭 系统的写缓存被刷新（可能是缓存已经被写满，或者定期保存操作被执行） 这三种情况下的 SAVE 操作都会引起 Redis 主进程阻塞。 每一秒钟保存一次在这种模式中， SAVE 原则上每隔一秒钟就会执行一次， 因为 SAVE 操作是由后台子线程调用的， 所以它不会引起服务器主进程阻塞。 注意， 在上一句的说明里面使用了词语“原则上”， 在实际运行中， 程序在这种模式下对 fsync 或 fdatasync 的调用并不是每秒一次， 它和调用 flushAppendOnlyFile 函数时 Redis 所处的状态有关。 每当 flushAppendOnlyFile 函数被调用时， 可能会出现以下四种情况： 子进程正在执行SAVE，并且： 这个SAVE的执行时间未超过2秒，那么程序直接返回，并不执行WRITE或新的SAVE 这个SAVE已经执行超过了2秒，那么程序执行WRITE，单不执行新的SAVE。注意，因为这时的WRITE的写入必须等待子线程先完成（旧的）SAVE，因此这里WRITE会比平时阻塞更长时间 子进程没有在执行SAVE，并且： 上次成功执行 SAVE 距今不超过 1 秒，那么程序执行 WRITE ，但不执行 SAVE 。 次成功执行 SAVE 距今已经超过 1 秒，那么程序执行 WRITE 和 SAVE 。 如下图： 根据以上说明可以知道， 在“每一秒钟保存一次”模式下， 如果在情况 1 中发生故障停机， 那么用户最多损失小于 2 秒内所产生的所有数据。 如果在情况 2 中发生故障停机， 那么用户损失的数据是可以超过 2 秒的。 Redis 官网上所说的， AOF 在“每一秒钟保存一次”时发生故障， 只丢失 1 秒钟数据的说法， 实际上并不准确。 每执行一个命令保存一次在这种模式下，每次执行完一个命令之后， WRITE 和 SAVE 都会被执行。 另外，因为 SAVE 是由 Redis 主进程执行的，所以在 SAVE 执行期间，主进程会被阻塞，不能接受命令请求。 AOF 保存模式对性能和安全性的影响对于三种 AOF 保存模式， 它们对服务器主进程的阻塞情况如下： 不保存（AOF_FSYNC_NO）：写入和保存都由主进程执行，两个操作都会阻塞主进程。 每一秒钟保存一次（AOF_FSYNC_EVERYSEC）：写入操作由主进程执行，阻塞主进程。保存操作由子线程执行，不直接阻塞主进程，但保存操作完成的快慢会影响写入操作的阻塞时长。（上面flushAppendOnlyFile 第二种情况） 每执行一个命令保存一次（AOF_FSYNC_ALWAYS）：和模式 1 一样。 模式 1 的保存操作只会在AOF 关闭或 Redis 关闭时执行， 或者由操作系统触发， 在一般情况下， 这种模式只需要为写入阻塞， 因此它的写入性能要比后面两种模式要高， 当然， 这种性能的提高是以降低安全性为代价的： 在这种模式下， 如果运行的中途发生停机， 那么丢失数据的数量由操作系统的缓存冲洗策略决定。 模式 2 在性能方面要优于模式 3 ， 并且在通常情况下， 这种模式最多丢失不多于 2 秒的数据， 所以它的安全性要高于模式 1 ， 这是一种兼顾性能和安全性的保存方案。 模式 3 的安全性是最高的， 但性能也是最差的， 因为服务器必须阻塞直到命令信息被写入并保存到磁盘之后， 才能继续处理请求。 综合起来，三种 AOF 模式的操作特性可以总结如下： 模式 WRITE 是否阻塞？ SAVE 是否阻塞？ 停机时丢失的数据量 AOF_FSYNC_NO 阻塞 阻塞 操作系统最后一次对 AOF 文件触发 SAVE 操作之后的数据。 AOF_FSYNC_EVERYSEC 阻塞 不阻塞 一般情况下不超过 2 秒钟的数据。 AOF_FSYNC_ALWAYS 阻塞 阻塞 最多只丢失一个命令的数据。","link":"/2019/11/10/redis%E6%8C%81%E4%B9%85%E5%8C%96/"}],"tags":[{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"分布式","slug":"分布式","link":"/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"nosql","slug":"nosql","link":"/tags/nosql/"},{"name":"redis","slug":"redis","link":"/tags/redis/"}],"categories":[{"name":"分布式","slug":"分布式","link":"/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"“nginx”","slug":"分布式/“nginx”","link":"/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E2%80%9Cnginx%E2%80%9D/"},{"name":"redis","slug":"redis","link":"/categories/redis/"}]}